//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Text;
using System.Collections.Generic;

public class TerminalController {
	const int TERMINAL_WIDTH = 80;
	const int TERMINAL_HEIGHT = 25;

	public Dictionary<string, ITerminalCommand> commands;
	
	public Stack<TerminalFileData> workingDirectory;
	public TerminalFileData root;

	private int topLine;
	private char [][] terminalDisplay;	// jagged array for tomfoolery

	public bool displayDirty;

	public TerminalController () {
		// this could go either way - either keep an instance around of a given class *or* instantiate a new
		// one for each execution - going with this way right now so the commands can keep their own internal state
		// because that sounds helpful
		commands = new Dictionary<string, ITerminalCommand>();

		terminalDisplay = new char[TERMINAL_HEIGHT][];	// first is row, second is column
		for (int i = 0; i < TERMINAL_HEIGHT; i++) {
			terminalDisplay[i] = new char[TERMINAL_WIDTH];
		}

		// FILL IT WITH SOMETHING!
		FillTerminal(' ');
		topLine = 0;
		displayDirty = true;

		commands.Add("cd", new TerminalCommandCd());
		commands.Add("help", new TerminalCommandHelp());
		commands.Add("ls", new TerminalCommandLs());
		commands.Add("pwd", new TerminalCommandPwd());

		PrintString("MooseTerminal v0.87");
		PrintString("Online!\n\n\n:)");

		root = new TerminalFileData("/", "root", new List<TerminalFileData>());
		workingDirectory = new Stack<TerminalFileData>();
		workingDirectory.Push(root);

		BuildFileSystem();
	}

	void BuildFileSystem() {
		// this could be data...orrrrr just define it all here

		TerminalFileData usersDir = new TerminalFileData("users", "root", new List<TerminalFileData>());
		root.children.Add(usersDir);

		TerminalFileData logsDir = new TerminalFileData("logs", "root", new List<TerminalFileData>());
		root.children.Add(logsDir);

		logsDir.children.Add(new TerminalFileData("log.5/31/2766", "loggr", "compressed log"));
		logsDir.children.Add(new TerminalFileData("log.6/1/2766", "loggr", "compressed log"));
		logsDir.children.Add(new TerminalFileData("log.6/2/2766", "---", "ERR"));
		logsDir.children.Add(new TerminalFileData("log.6/3/2766", "loggr", "compressed log"));

		TerminalFileData readme = new TerminalFileData("readme", "root", "text");
		root.children.Add (readme);
	}

	public void FillTerminal(char fillChar) {
		for (int y = 0; y < TERMINAL_HEIGHT; y++) {
			for (int x = 0; x < TERMINAL_WIDTH; x++) {
				terminalDisplay[y][x] = fillChar;
			}
		}
	}

	public void ExecuteCommand(string commandString) {
		PrintString (string.Format("> {0}", commandString));

		string[] args = commandString.Split (new char[] {' '});

		if (args.Length < 1) {
			PrintString ("You must enter input");
		}

		string command = args[0];

		if (commands.ContainsKey(command)) {
			ITerminalCommand fullCommand = commands[command];
			fullCommand.Execute(args, this);
		} else {
			PrintString(string.Format("Unknown command \"{0}\"", command));
		}
	}

	public void PrintString(string toPrint) {
		string[] components = toPrint.Split(new char[] {'\n'});

		for (int i = 0; i < components.Length; i++) {
			char[] row = terminalDisplay[(topLine + i) % TERMINAL_HEIGHT];
			string component = components[i];
			char[] charArray = component.ToCharArray();

			// TODO: line wrap
			for (int j = 0; j < TERMINAL_WIDTH; j++) {
				if (j < charArray.Length) {
					row[j] = charArray[j];
				} else {
					row[j] = ' ';
				}
			}
		}

		topLine = (topLine + components.Length) % TERMINAL_HEIGHT;

		displayDirty = true;
	}

	public string StringifyTerminal() {
		StringBuilder builder = new StringBuilder();

		for (int i = 0; i < TERMINAL_HEIGHT; i++) {
			// access circular buffer of rows
			char[] row = terminalDisplay[(topLine + i) % TERMINAL_HEIGHT];
			builder.AppendLine(new string(row));
		}

		return builder.ToString();
	}
}


